---
title: "Single-cell transcriptomics identifies an effectorness gradient shaping the
  response of CD4+ T cells to cytokines"
author: "Cano-Gomez et al., Nature Communications 11, 1801(2020)"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## RNA Sequencing

**RNA-seq Technology** is a powerful method used to analyze the transcriptome, which is the complete set of RNA molecules expressed in a cell or a population of cells. It allows researchers to measure gene expression levels, identify novel transcripts, and discover alternative splicing events.

Main Steps of RNA-seq Technology:

1.  **Sample Collection**:

    -   Biological samples (e.g., tissues or cells) are collected to extract RNA.

2.  **RNA Extraction**:

    -   The total RNA is isolated from the collected samples, focusing on messenger RNA (mRNA) since it carries the genetic information for protein synthesis.

3.  **Library Preparation**:

    -   The extracted mRNA is fragmented into smaller pieces, and specific adapters are added to both ends of these fragments. This process creates a library of cDNA (complementary DNA) that can be sequenced.

4.  **Sequencing**:

    -   The prepared library is sequenced using high-throughput sequencing technologies, generating millions of short nucleotide sequences (reads).

5.  **Data Processing**:

    -   The raw sequencing data is processed to remove low-quality reads and contaminants. The reads are then aligned to a reference genome or transcriptome.

6.  **Quantification**:

    -   The number of reads mapped to each gene is counted, providing a measure of gene expression levels.

7.  **Normalization**:

    -   The raw counts are normalized to account for differences in sequencing depth and library size, allowing for accurate comparisons across samples.

8.  **Data Analysis**:

    -   Statistical analyses are performed to identify differentially expressed genes, alternative splicing events, and other relevant biological insights.

        Challenges in RNA-seq Data Normalization

    -   **Variable Sequencing Depth**:

        -   Different samples may have varying total reads, leading to biased comparisons if not normalized.

    -   **Library Size Differences**:

        -   The total number of reads can differ between samples, affecting gene expression interpretation.

    -   **Sparse Data**:

        -   Many genes may have low or zero expression levels, complicating normalization and analysis.

    -   **Batch Effects**:

        -   Variations during sample processing or sequencing can confound results, requiring normalization to address these effects.

    -   **Choice of Normalization Method**:

        -   Various methods exist, and selecting the appropriate one can be challenging, as each has different assumptions.

    -   **Biological Variability**:

        -   Differences between samples (e.g., cell types or conditions) can affect gene expression, necessitating careful normalization.

## Dataset Description

This analysis uses **bulk RNA sequencing data** from human CD4+ T cells, originally generated by Cano-Gomez et al. (2020).

**Raw Counts (`RNA_seq_raw_counts.txt.gz`)**\
- **Size:** 58,051 genes × 94 samples.\
- **Format:** Rows are genes (Ensembl IDs), columns are samples. Values are raw read counts.

**Metadata (`bulk_RNAseq_metadata.txt.gz`)**\
- **Size:** 94 samples × 10 variables.\
- **Variables:** - `sample_id`: Sample identifier\
- `cell_type`: CD4+ T cell subset (Naive, Memory)\
- `cytokine_condition`: Cytokine stimulation condition (IFNB, Th0, Th2, Th17, Resting)\
- `stimulation_time`: Duration of stimulation (16h, 5d)\
- `donor_id`: Donor identifier\
- `sex`: Donor sex\
- `age`: Donor age in years\
- `sequencing_batch`: Sequencing batch number\
- `cell_culture_batch`: Cell culture batch number

This dataset allows analysis of gene expression differences across cell types, stimulation conditions, and donors, controlling for batch effects.

## Loading and pre-processing

### Libraries

```{r cars}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("DESeq2")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("vsn")
```

```{r}
library(DESeq2)
library(vsn)

```

### Loading expression data

This data is an example for processing **bulk RNA-sequencing (RNA-seq)** count data.\
In RNA-seq analysis, messenger RNA (mRNA) molecules are fragmented into small RNA reads that are subsequently sequenced. These reads are then **mapped to a reference genome**, and for each gene, the total number of mapped reads (or *counts*) is quantified.

The resulting **gene expression count matrix** typically contains:

-   **Rows** → individual genes

-   **Columns** → biological samples

-   **Values** → raw read counts per gene per sample

This count matrix serves as the input for downstream analyses such as **normalization**, **differential expression**, and **functional enrichment**.

```{r}
# Set the working directory to access the data

ge_matrix = read.table("NCOMMS-19-7936188_bulk_RNAseq_raw_counts.txt.gz", header = TRUE)

dim(ge_matrix)

# columns are samples
# rows are genes
# values are the number of the reads which are mapped to the genes in each sample

# Only a subset of data
ge_matrix[1:10, 1:10]
```

### Loading Meta-data

Alongside the expression count matrix, **metadata** is required to describe the biological and experimental context of each sample.\
The metadata file typically includes information such as:

-   **Sample ID** — unique identifier matching the column names in the count matrix

-   **Phenotype / Condition** — e.g., control vs. treated, wild-type vs. mutant

-   **Cell type or tissue** — biological source of the RNA

-   **Batch or replicate information** — technical or biological replicates

This metadata is essential for downstream analyses, such as **differential expression**, where we test how gene expression varies between experimental

```{r}
path <- "NCOMMS-19-7936188_bulk_RNAseq_metadata.txt.gz"

pheno_matrix <- read.table(path, header = TRUE, stringsAsFactors = TRUE)

pheno_matrix[1:10, 1:10]
dim(pheno_matrix)

```

## Organizing data

Before analysis, it’s crucial to ensure that the **sample identifiers** in the metadata correspond exactly to the **sample columns** in the expression matrix.\
Both datasets must have the same samples in the same order to avoid misalignment during downstream analysis.

```{r}
# Assign sample IDs as row names in the metadata
rownames(pheno_matrix) <-  pheno_matrix$sample_id

# Inspect dimensions and structure
dim(pheno_matrix)
head(pheno_matrix)
```

```{r}
# Verify sample alignment between metadata and expression matrix
all(rownames(pheno_matrix) == colnames(ge_matrix))
```

The output is `TRUE`, o the metadata and expression data are correctly aligned. Otherwise, reordering or subsetting would be required before proceeding.

```{r}
colnames(pheno_matrix)
```

```{r}
pheno_matrix$stimulation_time
```

### Sub-setting data

For the purpose of this analysis, we focus on a specific subset of samples:\
**CD4⁺ memory T cells** collected **after 5 days of treatment** compared to **control** conditions.

Filtering the dataset to this subset ensures that the differential expression results specifically reflect the treatment effect in this cell type and time point.

```{r}
# Subset metadata for CD4+ memory cells at day 5
stimulation_time    <- '5d'
conditions  <- c('Th2', 'Th0')
celltype    <- 'CD4_Memory'

toSelect <-  pheno_matrix$stimulation_time == stimulation_time &
  pheno_matrix$cytokine_condition %in% conditions &
  pheno_matrix$cell_type == celltype
  
# Subset expression matrix accordingly
pheno_matrix.subset <-pheno_matrix[toSelect, ] 
ge_matrix.subset <-  ge_matrix [ ,toSelect]
```

## Creating DESeq2 object

To perform **differential expression analysis**, we create a `DESeqDataSet` object from the expression counts and corresponding metadata.\
The **design formula** specifies the biological variable of interest — in this case, the **cytokine condition** (TH2 vs. TH0) in **CD4⁺ memory cells** after 5 days.

```{r}
dds <-  DESeqDataSetFromMatrix(countData = ge_matrix.subset, #gene expression
                               colData = pheno_matrix.subset, #meta data
                               design = ~ cytokine_condition) #the question that is important to use to compare: we want to see the differece between CD4_Memory cells after 5 days in TH2 & TH0 condions 
head(dds)
```

### Filtering low-expressed gene

Before running the differential expression analysis, genes with **no or very low counts** across all samples should be removed.\
These genes add noise and reduce statistical power, as they don’t provide meaningful signal for DESeq2’s model.

```{r}

# This keeps genes that have at least 10 counts total across all samples, which is standard before differential expression (DE) testing.
keep <-  rowSums(counts(dds)) >= 10
dds <- dds[keep, ]
dds
```

## Variance stabilization for visualization

While **DESeq2** operates on **raw count data** for statistical modeling, most visualization and exploratory analyses (e.g. PCA, clustering, correlation) assume data with an approximately **normal distribution**. To achieve this, we apply transformations that stabilize the variance across genes — especially those with low expression levels.

### Log2 transformation (with Pseudocount)

A simple approach is to apply a log₂ transformation with a small pseudocount (commonly 1) to avoid undefined values for zeros:

log2-transformed=log⁡2(raw count+1)

example:

| Gene  | Sample1 | Sample2 |
|-------|---------|---------|
| gene1 | 0       | 5       |
| gene2 | 10      | 0       |

After transformation:

| Gene  | Sample1 | Sample2 |
|-------|---------|---------|
| gene1 | 0.00    | 2.58    |
| gene2 | 3.46    | 0.00    |

-   Zero counts remain 0 (after adding pseudocount 1)

-   High counts are **compressed**, reducing variance differences

-   Patterns become easier to interpret in **PCA**, **heatmaps**, and **correlation plots**

#### ⚠️ Note on Low Counts

If low-count genes were **not filtered out** in the previous step, basic log-transformation may exaggerate noise.\
In such cases, use DESeq2’s **regularized transformations**, which handle variance more robustly:

```{r}
# Not to be run this cell for now
# Regularized log transformation
rld <- rlog(dds)
assay(rld)[1:5, 1:5]

# Variance stabilizing transformation
vsd <- vst(dds)
assay(vsd)[1:5, 1:5]
```

To visualize RNA-seq data, we often apply transformations that **stabilize variance across genes**. DESeq2 provides multiple options:

```{r}
# Apply a pseudocount of 1 and apply log2
# For DE testing, you don’t use normTransform(); it’s only for visualization. DESeq2 internally models counts directly.
normtfd <- normTransform(dds, f = log2, pc = 1)
# Compare mean to sd
meanSdPlot(assay(normtfd))
```

-   Observations:

    -   **Highly expressed genes** have relatively low standard deviation.

    -   **Medium-expressed genes** can show high variance.

    -   Standard deviation is **not homogeneous** across expression levels, which can bias clustering and visualization.

-   **Important:** `normTransform()` is **only for visualization**, not for differential expression testing. DESeq2 internally models raw counts directly. One uses `normTransform()` mainly for **speed and convenience** in exploratory visualization when extreme precision isn’t critical.

```{r}
# Let's calculate rlog values and take another look.
rltfd <- rlog(dds, blind=FALSE)
meanSdPlot(assay(rltfd))
```

-   rlog stabilizes the variance across all expression levels, including low- and medium-expressed genes.

-   After rlog, **standard deviations become more uniform**, making PCA, clustering, and heatmaps more interpretable.

### Normalization

RNA-seq libraries often have **different sequencing depths** — i.e., some samples have more total reads than others. Directly comparing raw counts between samples can therefore be misleading.

A simple approach like **Counts Per Million (CPM)** can make samples more comparable, but it is **highly sensitive to outliers**. For example, if a few genes are extremely highly expressed in one sample, CPM-based normalization can be skewed.

DESeq2 addresses this using **size factor normalization**:

-   It identifies a set of **“stable” genes** whose expression is roughly consistent across samples.

-   The **size factor** for each sample is calculated based on these genes.

-   All raw counts in that sample are then **scaled by its size factor**, making samples comparable while accounting for sequencing depth and composition differences.

```{r}
dds <- estimateSizeFactors(dds)
# each sample has one size factor for seq depths
dds$sizeFactor
```

```{r}
plot(dds$sizeFactor, 
    colSums(counts(dds, normalized=F)), 
    xlab = 'Size factor',
    ylab = 'Total number of reads', 
    pch = 19)
```

```{r}
dds$sizeFactor
```

-   After applying size factors, DESeq2 effectively works with **pseudo counts** internally, which are adjusted counts used for statistical modeling.

-   This ensures that downstream differential expression analysis is **not biased by library size or extreme outliers**.

## Principal componant analysis (PCA)

PCA is a standard technique to explore and visualize **overall patterns in gene expression data**.\
Since PCA assumes that features (genes) are roughly **normally distributed**, we first transform the count data using **rlog**to account for library size and stabilize variance.

```{r}
# Perform PCA on rlog-transformed data
rltfd.pca <-  prcomp(t(assay(rltfd)), scale = TRUE)

```

#### Why transpose the matrix?

-   `prcomp()` expects **rows = observations** and **columns = variables**.

-   In RNA-seq data:

    -   **Rows → samples**

    -   **Columns → genes**

-   The `t()` ensures that **samples become rows** and **genes become columns**, so PCA treats each sample as an observation.

####  What does `scale = TRUE` do?

-   Each gene (column) is **centered and scaled**:

    xscaled=x−mean(x)sd(x) ​

-   This standardizes the variance across genes.

**Why it matters biologically:**

-   Some genes, like **housekeeping genes**, are very highly expressed, while others, like **transcription factors**, have lower absolute expression.

-   Without scaling, highly expressed genes dominate the principal components, potentially masking biologically meaningful variation in lowly expressed but variable genes.

-   Scaling ensures that **all genes contribute equally** to the PCA, highlighting meaningful differences rather than just magnitude differences.

####  What does `scale = FALSE` do?

-   **Interpretation:** PCA will give more weight to genes with **higher absolute variance** or expression levels.

-   **Use case:**

    -   You want to capture the **dominant signals** in the data, e.g., highly expressed genes or strong technical differences.

    -   For example, if you’re analyzing **housekeeping genes or very high-count genes**, and their absolute expression differences are biologically meaningful, scaling could actually reduce that signal.

```{r}
require(factoextra)
fviz_eig(rltfd.pca)

fviz_pca_ind(rltfd.pca)
```

```{r}
object=rltfd
intgroup = 'sequencing_batch'
ntop=26656  
returnData = FALSE
  
      rv <- MatrixGenerics::rowVars(assay(object))
      select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
            length(rv)))]
      #if the variabiloty is important we use scale
      #pca <- prcomp(t(assay(object)[, ])) 
      pca <- prcomp(t(assay(object)[, ]),scale=TRUE)
      percentVar <- pca$sdev^2/sum(pca$sdev^2)
      
      if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
      }
        intgroup.df <- as.data.frame(colData(object)[, intgroup, 
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        } else {
            colData(object)[[intgroup]]
        }
        d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], group = group, 
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[1:2]
            return(d)
        }
        ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = "group")) + 
            geom_point(size = 3) + xlab(paste0("PC1: ", round(percentVar[1] * 
            100), "% variance")) + ylab(paste0("PC2: ", round(percentVar[2] * 
            100), "% variance")) + coord_fixed()
```

```{r}

object=rltfd
intgroup = 'cytokine_condition'
ntop=26656  
returnData = FALSE
  
      rv <- MatrixGenerics::rowVars(assay(object))
      select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, 
            length(rv)))]
      #if the variabiloty is important we use scale
      #pca <- prcomp(t(assay(object)[, ])) 
      pca <- prcomp(t(assay(object)[, ]),scale=TRUE)
      percentVar <- pca$sdev^2/sum(pca$sdev^2)
      
      if (!all(intgroup %in% names(colData(object)))) {
            stop("the argument 'intgroup' should specify columns of colData(dds)")
      }
        intgroup.df <- as.data.frame(colData(object)[, intgroup, 
            drop = FALSE])
        group <- if (length(intgroup) > 1) {
            factor(apply(intgroup.df, 1, paste, collapse = ":"))
        } else {
            colData(object)[[intgroup]]
        }
        d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], group = group, 
            intgroup.df, name = colnames(object))
        if (returnData) {
            attr(d, "percentVar") <- percentVar[1:2]
            return(d)
        }
        ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = "group")) + 
            geom_point(size = 3) + xlab(paste0("PC1: ", round(percentVar[1] * 
            100), "% variance")) + ylab(paste0("PC2: ", round(percentVar[2] * 
            100), "% variance")) + coord_fixed()
```

## Differential expression analysis

RNA-seq data consists of **counts**, which are **not normally distributed**, making standard tests like the t-test unsuitable.

-   **Model:** Counts are better described by a **negative binomial distribution**, which accounts for the mean–variance relationship.

-   **Parameters:**

    -   **Mean count** – average expression

    -   **Overdispersion (α)** – how variance relates to the mean (low α ≈ variance close to mean)

-   **Challenges:** Low sample sizes or lowly expressed genes can produce unstable variance estimates.

-   **Solution:** DESeq2 and similar packages **shrink extreme variance and overdispersion estimates**, stabilizing results and enabling reliable identification of differentially expressed genes.

```{r}
library(DESeq2)
BiocManager::install("EnhancedVolcano")a
library(EnhancedVolcano)
library(pheatmap)
```

```{r}
dds <-  DESeq((dds))
```

```{r}
# results: Extract results from a DESeq analysis giving base means across samples, log2 fold changes, standard errors, test statistics, p-values and adjusted p-values; resultsNames returns the names of the estimated effects (coefficents) of the model; removeResults returns a DESeqDataSet object with results columns removed

res <- results(dds)

dim(res)
res
```

| Column | Meaning | How to interpret |
|--------|---------|------------------|

|  |  |  |
|------------------------|------------------------|------------------------|
| **baseMean** | The **average normalized expression** of that gene across *all samples* (Th0 + Th2). | Higher = more overall expression. Low baseMean = low counts, less reliable estimates. |

|  |  |  |
|------------------------|------------------------|------------------------|
| **log2FoldChange** | Estimated **log₂ difference** in expression between Th2 and Th0. | +1 = 2× higher in Th2, −1 = 2× lower in Th2. |

|  |  |  |
|------------------------|------------------------|------------------------|
| **lfcSE** | **Standard error** of the log₂ fold change estimate. | Measures uncertainty. Large SE = unstable estimate. |

|  |  |  |
|------------------------|------------------------|------------------------|
| **stat** | The **Wald test statistic** (≈ log2FC / lfcSE). | Used to compute the p-value. |

|  |  |  |
|------------------------|------------------------|------------------------|
| **pvalue** | Raw p-value from the Wald test. | Probability that this log2FC is due to random noise. |

|  |  |  |
|------------------------|------------------------|------------------------|
| **padj** | **Adjusted p-value (FDR)** using Benjamini–Hochberg correction. | Controls false discoveries across thousands of genes. Use this for deciding significance. |

```{r}
# significantly differentially expressed genes number

sum(res$padj <= 0.01 &
      abs(res$log2FoldChange) > 1, na.rm = TRUE)
```

```{r}
# visual 1

EnhancedVolcano(res, lab = rownames(res), 
                x = 'log2FoldChange', y = 'padj', 
                subtitle = 'Th2 vs Th0', labSize = 3, 
                pCutoff = 0.01,
                FCcutoff = 1,
                drawConnectors = TRUE)

# x axis log fold change: how strong is the change
# y axis is the p-value
```

A volcano plot visualizes **differential expression results** by combining **statistical significance** and **magnitude of change**:

-   **X-axis:** log₂ fold change (direction and magnitude of expression change)

-   **Y-axis:** -log₁₀(p-value) (statistical significance)

-   **Points color-coded:**

    -   **Gray (NS):** not significant

    -   **Green:** significant by log₂FC only

    -   **Blue:** significant by p-value only

    -   **Red:** significant by both log₂FC and p-value

**Observations:**

-   Most red points are located at **high absolute log₂FC values**, showing genes with strong and statistically significant differential expression.

-   Genes near the center (between vertical dotted lines) are statistically significant but with **small fold changes** → less biologically meaningful.

-   Some genes have **very high log₂FC and low p-values**, making them prime candidates for downstream functional analysis.

**Takeaway:** The volcano plot highlights a **subset of genes with strong, significant changes** between Th2 and Th0, which aligns with the patterns observed in the heatmap.

```{r}
# visual 2: heatmap

DEG.idx <- which(res$padj <= 0.01 & 
      abs(res$log2FoldChange) > 1)
res[DEG.idx,]
df <- as.data.frame(colData(dds)[,c("cytokine_condition","donor_id", "sequencing_batch")])
```

```{r}
pheatmap(assay(rltfd)[DEG.idx,], annotation_col=df,
    treeheight_row = 0, treeheight_col = 0, scale = "row")
```

-   The heatmap shows **expression patterns of differentially expressed genes (DEGs)** across samples.

-   **Rows:** genes (DEGs filtered by adjusted p-value ≤ 0.01 and \|log₂FC\| \> 1)

-   **Columns:** samples

-   **Annotations:**

    -   `cytokine_condition` (Th0 vs Th2)

    -   `donor_id`

    -   `sequencing_batch`

**Observations:**

-   Clear separation between Th0 and Th2 samples — upregulated genes in Th2 are shown in **warm colors (orange/red)**, downregulated in **cool colors (blue)**.

-   Minimal batch effect visible — samples from different sequencing batches cluster largely by condition, not batch.

-   Donor variation is present but secondary to the treatment effect.

**Takeaway:** The heatmap confirms that the DEGs reflect **biologically meaningful differences between Th2 and Th0 conditions**.

## Overall conclusion:

-   Both visualizations confirm that **Th2 treatment induces clear transcriptional changes** in CD4⁺ memory cells.

-   Red genes in the volcano plot correspond to the most strongly up- or downregulated genes in the heatmap.

-   These genes are **primary candidates for functional analysis** to understand the biological effect of the treatment.
